/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace test_cpp2 { namespace cpp_reflection {

class union1;
class union2;
class union3;
class structA;
class structB;
class struct1;
class struct2;
class struct3;

enum class enum1 {
  field0 = 0,
  field1 = 1,
  field2 = 2
};

extern const std::map<enum1, const char*> _enum1_VALUES_TO_NAMES;
extern const std::map<const char*, enum1, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection
namespace std {

template<> struct hash<typename  ::test_cpp2::cpp_reflection::enum1> : public apache::thrift::detail::enum_hash<typename  ::test_cpp2::cpp_reflection::enum1> {};
template<> struct equal_to<typename  ::test_cpp2::cpp_reflection::enum1> : public apache::thrift::detail::enum_equal_to<typename  ::test_cpp2::cpp_reflection::enum1> {};

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findName( ::test_cpp2::cpp_reflection::enum1 value);
template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum1* outValue);

template <> constexpr  ::test_cpp2::cpp_reflection::enum1 TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::min() {
  return  ::test_cpp2::cpp_reflection::enum1::field0;
}

template <> constexpr  ::test_cpp2::cpp_reflection::enum1 TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::max() {
  return  ::test_cpp2::cpp_reflection::enum1::field2;
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum class enum2 {
  field0_2 = 0,
  field1_2 = 1,
  field2_2 = 2
};

extern const std::map<enum2, const char*> _enum2_VALUES_TO_NAMES;
extern const std::map<const char*, enum2, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection
namespace std {

template<> struct hash<typename  ::test_cpp2::cpp_reflection::enum2> : public apache::thrift::detail::enum_hash<typename  ::test_cpp2::cpp_reflection::enum2> {};
template<> struct equal_to<typename  ::test_cpp2::cpp_reflection::enum2> : public apache::thrift::detail::enum_equal_to<typename  ::test_cpp2::cpp_reflection::enum2> {};

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findName( ::test_cpp2::cpp_reflection::enum2 value);
template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum2* outValue);

template <> constexpr  ::test_cpp2::cpp_reflection::enum2 TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::min() {
  return  ::test_cpp2::cpp_reflection::enum2::field0_2;
}

template <> constexpr  ::test_cpp2::cpp_reflection::enum2 TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::max() {
  return  ::test_cpp2::cpp_reflection::enum2::field2_2;
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum class enum3 {
  field0_3 = 0,
  field1_3 = 1,
  field2_3 = 2
};

extern const std::map<enum3, const char*> _enum3_VALUES_TO_NAMES;
extern const std::map<const char*, enum3, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection
namespace std {

template<> struct hash<typename  ::test_cpp2::cpp_reflection::enum3> : public apache::thrift::detail::enum_hash<typename  ::test_cpp2::cpp_reflection::enum3> {};
template<> struct equal_to<typename  ::test_cpp2::cpp_reflection::enum3> : public apache::thrift::detail::enum_equal_to<typename  ::test_cpp2::cpp_reflection::enum3> {};

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findName( ::test_cpp2::cpp_reflection::enum3 value);
template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum3* outValue);

template <> constexpr  ::test_cpp2::cpp_reflection::enum3 TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::min() {
  return  ::test_cpp2::cpp_reflection::enum3::field0_3;
}

template <> constexpr  ::test_cpp2::cpp_reflection::enum3 TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::max() {
  return  ::test_cpp2::cpp_reflection::enum3::field2_3;
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class union1 : private boost::totally_ordered<union1> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui = 1,
    ud = 2,
    us = 3,
    ue = 4,
  } ;

  union1() :
      type_(Type::__EMPTY__) {}

  union1(union1&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union1(const union1& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union1& operator=(union1&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union1& operator=(const union1& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~union1() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui;
    double ud;
    std::string us;
     ::test_cpp2::cpp_reflection::enum1 ue;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union1& rhs) const;

  bool operator < (const union1& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::ui:
      {
        return value_.ui < rhs.value_.ui;
        break;
      }
      case Type::ud:
      {
        return value_.ud < rhs.value_.ud;
        break;
      }
      case Type::us:
      {
        return value_.us < rhs.value_.us;
        break;
      }
      case Type::ue:
      {
        return value_.ue < rhs.value_.ue;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  template<typename... T>
  void set_ui(T&&... t) {
    __clear();
    type_ = Type::ui;
    new (&value_.ui) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ud(T&&... t) {
    __clear();
    type_ = Type::ud;
    new (&value_.ud) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_us(T&&... t) {
    __clear();
    type_ = Type::us;
    new (&value_.us) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ue(T&&... t) {
    __clear();
    type_ = Type::ue;
    new (&value_.ue)  ::test_cpp2::cpp_reflection::enum1(std::forward<T>(t)...);
  }

  const int32_t& get_ui() const {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  const double& get_ud() const {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  const std::string& get_us() const {
    assert(type_ == Type::us);
    return value_.us;
  }

  const  ::test_cpp2::cpp_reflection::enum1& get_ue() const {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t& mutable_ui() {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double& mutable_ud() {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  std::string& mutable_us() {
    assert(type_ == Type::us);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1& mutable_ue() {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t move_ui() {
    assert(type_ == Type::ui);
    return std::move(value_.ui);
  }

  double move_ud() {
    assert(type_ == Type::ud);
    return std::move(value_.ud);
  }

  std::string move_us() {
    assert(type_ == Type::us);
    return std::move(value_.us);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue() {
    assert(type_ == Type::ue);
    return std::move(value_.ue);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(union1& a, union1& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::clear( ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class union2 : private boost::totally_ordered<union2> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui_2 = 1,
    ud_2 = 2,
    us_2 = 3,
    ue_2 = 4,
  } ;

  union2() :
      type_(Type::__EMPTY__) {}

  union2(union2&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union2(const union2& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union2& operator=(union2&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union2& operator=(const union2& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~union2() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui_2;
    double ud_2;
    std::string us_2;
     ::test_cpp2::cpp_reflection::enum1 ue_2;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union2& rhs) const;

  bool operator < (const union2& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::ui_2:
      {
        return value_.ui_2 < rhs.value_.ui_2;
        break;
      }
      case Type::ud_2:
      {
        return value_.ud_2 < rhs.value_.ud_2;
        break;
      }
      case Type::us_2:
      {
        return value_.us_2 < rhs.value_.us_2;
        break;
      }
      case Type::ue_2:
      {
        return value_.ue_2 < rhs.value_.ue_2;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  template<typename... T>
  void set_ui_2(T&&... t) {
    __clear();
    type_ = Type::ui_2;
    new (&value_.ui_2) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ud_2(T&&... t) {
    __clear();
    type_ = Type::ud_2;
    new (&value_.ud_2) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_us_2(T&&... t) {
    __clear();
    type_ = Type::us_2;
    new (&value_.us_2) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ue_2(T&&... t) {
    __clear();
    type_ = Type::ue_2;
    new (&value_.ue_2)  ::test_cpp2::cpp_reflection::enum1(std::forward<T>(t)...);
  }

  const int32_t& get_ui_2() const {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  const double& get_ud_2() const {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  const std::string& get_us_2() const {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

  const  ::test_cpp2::cpp_reflection::enum1& get_ue_2() const {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t& mutable_ui_2() {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double& mutable_ud_2() {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  std::string& mutable_us_2() {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1& mutable_ue_2() {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t move_ui_2() {
    assert(type_ == Type::ui_2);
    return std::move(value_.ui_2);
  }

  double move_ud_2() {
    assert(type_ == Type::ud_2);
    return std::move(value_.ud_2);
  }

  std::string move_us_2() {
    assert(type_ == Type::us_2);
    return std::move(value_.us_2);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue_2() {
    assert(type_ == Type::ue_2);
    return std::move(value_.ue_2);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(union2& a, union2& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::clear( ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class union3 : private boost::totally_ordered<union3> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui_3 = 1,
    ud_3 = 2,
    us_3 = 3,
    ue_3 = 4,
  } ;

  union3() :
      type_(Type::__EMPTY__) {}

  union3(union3&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union3(const union3& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union3& operator=(union3&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union3& operator=(const union3& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~union3() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui_3;
    double ud_3;
    std::string us_3;
     ::test_cpp2::cpp_reflection::enum1 ue_3;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union3& rhs) const;

  bool operator < (const union3& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::ui_3:
      {
        return value_.ui_3 < rhs.value_.ui_3;
        break;
      }
      case Type::ud_3:
      {
        return value_.ud_3 < rhs.value_.ud_3;
        break;
      }
      case Type::us_3:
      {
        return value_.us_3 < rhs.value_.us_3;
        break;
      }
      case Type::ue_3:
      {
        return value_.ue_3 < rhs.value_.ue_3;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  template<typename... T>
  void set_ui_3(T&&... t) {
    __clear();
    type_ = Type::ui_3;
    new (&value_.ui_3) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ud_3(T&&... t) {
    __clear();
    type_ = Type::ud_3;
    new (&value_.ud_3) double(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_us_3(T&&... t) {
    __clear();
    type_ = Type::us_3;
    new (&value_.us_3) std::string(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_ue_3(T&&... t) {
    __clear();
    type_ = Type::ue_3;
    new (&value_.ue_3)  ::test_cpp2::cpp_reflection::enum1(std::forward<T>(t)...);
  }

  const int32_t& get_ui_3() const {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  const double& get_ud_3() const {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  const std::string& get_us_3() const {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

  const  ::test_cpp2::cpp_reflection::enum1& get_ue_3() const {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t& mutable_ui_3() {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double& mutable_ud_3() {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  std::string& mutable_us_3() {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1& mutable_ue_3() {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t move_ui_3() {
    assert(type_ == Type::ui_3);
    return std::move(value_.ui_3);
  }

  double move_ud_3() {
    assert(type_ == Type::ud_3);
    return std::move(value_.ud_3);
  }

  std::string move_us_3() {
    assert(type_ == Type::us_3);
    return std::move(value_.us_3);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue_3() {
    assert(type_ == Type::ue_3);
    return std::move(value_.ue_3);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(union3& a, union3& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::clear( ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class structA : private boost::totally_ordered<structA> {
 public:

  structA() :
      a(0) {}
  // FragileConstructor for use in initialization lists only

  structA(apache::thrift::FragileConstructor, int32_t a__arg, std::string b__arg) :
      a(std::move(a__arg)),
      b(std::move(b__arg)) {}

  structA(structA&&) = default;

  structA(const structA&) = default;

  structA& operator=(structA&&) = default;

  structA& operator=(const structA&) = default;
  void __clear();

  virtual ~structA() throw() {}

  int32_t a;
  std::string b;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      a = false;
      b = false;
    }

    bool a;
    bool b;
  } __isset;
  bool operator==(const structA& rhs) const;

  bool operator < (const structA& rhs) const {
    if (!(a == rhs.a)) {
      return a < rhs.a;
    }
    if (!(b == rhs.b)) {
      return b < rhs.b;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(structA& a, structA& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::clear( ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class structB : private boost::totally_ordered<structB> {
 public:

  structB() :
      c(0),
      d(0) {}
  // FragileConstructor for use in initialization lists only

  structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
      c(std::move(c__arg)),
      d(std::move(d__arg)) {}

  structB(structB&&) = default;

  structB(const structB&) = default;

  structB& operator=(structB&&) = default;

  structB& operator=(const structB&) = default;
  void __clear();

  virtual ~structB() throw() {}

  double c;
  bool d;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      c = false;
      d = false;
    }

    bool c;
    bool d;
  } __isset;
  bool operator==(const structB& rhs) const;

  bool operator < (const structB& rhs) const {
    if (!(c == rhs.c)) {
      return c < rhs.c;
    }
    if (!(d == rhs.d)) {
      return d < rhs.d;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(structB& a, structB& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::clear( ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class struct1 : private boost::totally_ordered<struct1> {
 public:

  struct1() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1()),
      field3( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  struct1(apache::thrift::FragileConstructor, int32_t field0__arg, std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::enum2 field3__arg,  ::test_cpp2::cpp_reflection::union1 field4__arg,  ::test_cpp2::cpp_reflection::union2 field5__arg) :
      field0(std::move(field0__arg)),
      field1(std::move(field1__arg)),
      field2(std::move(field2__arg)),
      field3(std::move(field3__arg)),
      field4(std::move(field4__arg)),
      field5(std::move(field5__arg)) {}

  struct1(struct1&&) = default;

  struct1(const struct1&) = default;

  struct1& operator=(struct1&&) = default;

  struct1& operator=(const struct1&) = default;
  void __clear();

  virtual ~struct1() throw() {}

  int32_t field0;
  std::string field1;
   ::test_cpp2::cpp_reflection::enum1 field2;
   ::test_cpp2::cpp_reflection::enum2 field3;
   ::test_cpp2::cpp_reflection::union1 field4;
   ::test_cpp2::cpp_reflection::union2 field5;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      field0 = false;
      field1 = false;
      field2 = false;
      field3 = false;
      field4 = false;
      field5 = false;
    }

    bool field0;
    bool field1;
    bool field2;
    bool field3;
    bool field4;
    bool field5;
  } __isset;
  bool operator==(const struct1& rhs) const;

  bool operator < (const struct1& rhs) const {
    if (!(field0 == rhs.field0)) {
      return field0 < rhs.field0;
    }
    if (!(field1 == rhs.field1)) {
      return field1 < rhs.field1;
    }
    if (!(field2 == rhs.field2)) {
      return field2 < rhs.field2;
    }
    if (!(field3 == rhs.field3)) {
      return field3 < rhs.field3;
    }
    if (!(field4 == rhs.field4)) {
      return field4 < rhs.field4;
    }
    if (!(field5 == rhs.field5)) {
      return field5 < rhs.field5;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(struct1& a, struct1& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::clear( ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class struct2 : private boost::totally_ordered<struct2> {
 public:

  struct2() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1()),
      fieldD( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  struct2(apache::thrift::FragileConstructor, int32_t fieldA__arg, std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
      fieldA(std::move(fieldA__arg)),
      fieldB(std::move(fieldB__arg)),
      fieldC(std::move(fieldC__arg)),
      fieldD(std::move(fieldD__arg)),
      fieldE(std::move(fieldE__arg)),
      fieldF(std::move(fieldF__arg)),
      fieldG(std::move(fieldG__arg)) {}

  struct2(struct2&&) = default;

  struct2(const struct2&) = default;

  struct2& operator=(struct2&&) = default;

  struct2& operator=(const struct2&) = default;
  void __clear();

  virtual ~struct2() throw() {}

  int32_t fieldA;
  std::string fieldB;
   ::test_cpp2::cpp_reflection::enum1 fieldC;
   ::test_cpp2::cpp_reflection::enum2 fieldD;
   ::test_cpp2::cpp_reflection::union1 fieldE;
   ::test_cpp2::cpp_reflection::union2 fieldF;
   ::test_cpp2::cpp_reflection::struct1 fieldG;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
    }

    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
  } __isset;
  bool operator==(const struct2& rhs) const;

  bool operator < (const struct2& rhs) const {
    if (!(fieldA == rhs.fieldA)) {
      return fieldA < rhs.fieldA;
    }
    if (!(fieldB == rhs.fieldB)) {
      return fieldB < rhs.fieldB;
    }
    if (!(fieldC == rhs.fieldC)) {
      return fieldC < rhs.fieldC;
    }
    if (!(fieldD == rhs.fieldD)) {
      return fieldD < rhs.fieldD;
    }
    if (!(fieldE == rhs.fieldE)) {
      return fieldE < rhs.fieldE;
    }
    if (!(fieldF == rhs.fieldF)) {
      return fieldF < rhs.fieldF;
    }
    if (!(fieldG == rhs.fieldG)) {
      return fieldG < rhs.fieldG;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(struct2& a, struct2& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::clear( ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class struct3 : private boost::totally_ordered<struct3> {
 public:

  struct3() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1()),
      fieldD( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  struct3(apache::thrift::FragileConstructor, int32_t fieldA__arg, std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg,  ::test_cpp2::cpp_reflection::union2 fieldH__arg, std::vector<int32_t> fieldI__arg, std::vector<std::string> fieldJ__arg, std::vector<std::string> fieldK__arg, std::vector< ::test_cpp2::cpp_reflection::structA> fieldL__arg, std::set<int32_t> fieldM__arg, std::set<std::string> fieldN__arg, std::set<std::string> fieldO__arg, std::set< ::test_cpp2::cpp_reflection::structB> fieldP__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
      fieldA(std::move(fieldA__arg)),
      fieldB(std::move(fieldB__arg)),
      fieldC(std::move(fieldC__arg)),
      fieldD(std::move(fieldD__arg)),
      fieldE(std::move(fieldE__arg)),
      fieldF(std::move(fieldF__arg)),
      fieldG(std::move(fieldG__arg)),
      fieldH(std::move(fieldH__arg)),
      fieldI(std::move(fieldI__arg)),
      fieldJ(std::move(fieldJ__arg)),
      fieldK(std::move(fieldK__arg)),
      fieldL(std::move(fieldL__arg)),
      fieldM(std::move(fieldM__arg)),
      fieldN(std::move(fieldN__arg)),
      fieldO(std::move(fieldO__arg)),
      fieldP(std::move(fieldP__arg)),
      fieldQ(std::move(fieldQ__arg)),
      fieldR(std::move(fieldR__arg)) {}

  struct3(struct3&&) = default;

  struct3(const struct3&) = default;

  struct3& operator=(struct3&&) = default;

  struct3& operator=(const struct3&) = default;
  void __clear();

  virtual ~struct3() throw() {}

  int32_t fieldA;
  std::string fieldB;
   ::test_cpp2::cpp_reflection::enum1 fieldC;
   ::test_cpp2::cpp_reflection::enum2 fieldD;
   ::test_cpp2::cpp_reflection::union1 fieldE;
   ::test_cpp2::cpp_reflection::union2 fieldF;
   ::test_cpp2::cpp_reflection::struct1 fieldG;
   ::test_cpp2::cpp_reflection::union2 fieldH;
  std::vector<int32_t> fieldI;
  std::vector<std::string> fieldJ;
  std::vector<std::string> fieldK;
  std::vector< ::test_cpp2::cpp_reflection::structA> fieldL;
  std::set<int32_t> fieldM;
  std::set<std::string> fieldN;
  std::set<std::string> fieldO;
  std::set< ::test_cpp2::cpp_reflection::structB> fieldP;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structB> fieldR;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
      fieldH = false;
      fieldI = false;
      fieldJ = false;
      fieldK = false;
      fieldL = false;
      fieldM = false;
      fieldN = false;
      fieldO = false;
      fieldP = false;
      fieldQ = false;
      fieldR = false;
    }

    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
  } __isset;
  bool operator==(const struct3& rhs) const;

  bool operator < (const struct3& rhs) const {
    if (!(fieldA == rhs.fieldA)) {
      return fieldA < rhs.fieldA;
    }
    if (!(fieldB == rhs.fieldB)) {
      return fieldB < rhs.fieldB;
    }
    if (!(fieldC == rhs.fieldC)) {
      return fieldC < rhs.fieldC;
    }
    if (!(fieldD == rhs.fieldD)) {
      return fieldD < rhs.fieldD;
    }
    if (!(fieldE == rhs.fieldE)) {
      return fieldE < rhs.fieldE;
    }
    if (!(fieldF == rhs.fieldF)) {
      return fieldF < rhs.fieldF;
    }
    if (!(fieldG == rhs.fieldG)) {
      return fieldG < rhs.fieldG;
    }
    if (!(fieldH == rhs.fieldH)) {
      return fieldH < rhs.fieldH;
    }
    if (!(fieldI == rhs.fieldI)) {
      return fieldI < rhs.fieldI;
    }
    if (!(fieldJ == rhs.fieldJ)) {
      return fieldJ < rhs.fieldJ;
    }
    if (!(fieldK == rhs.fieldK)) {
      return fieldK < rhs.fieldK;
    }
    if (!(fieldL == rhs.fieldL)) {
      return fieldL < rhs.fieldL;
    }
    if (!(fieldM == rhs.fieldM)) {
      return fieldM < rhs.fieldM;
    }
    if (!(fieldN == rhs.fieldN)) {
      return fieldN < rhs.fieldN;
    }
    if (!(fieldO == rhs.fieldO)) {
      return fieldO < rhs.fieldO;
    }
    if (!(fieldP == rhs.fieldP)) {
      return fieldP < rhs.fieldP;
    }
    if (!(fieldQ == rhs.fieldQ)) {
      return fieldQ < rhs.fieldQ;
    }
    if (!(fieldR == rhs.fieldR)) {
      return fieldR < rhs.fieldR;
    }
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(struct3& a, struct3& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::clear( ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

}} // test_cpp2::cpp_reflection