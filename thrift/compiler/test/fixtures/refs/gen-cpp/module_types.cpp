/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "module_types.h"

#include "module_reflection.h"

#include <algorithm>
#include <string.h>



uint32_t MyUnion::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_anInteger();
          xfer += iprot->readI32(this->value_.anInteger);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_aString();
          xfer += iprot->readString(this->value_.aString);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MyUnion::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyUnion");
  switch (type_) {
    case Type::anInteger: {
      xfer += oprot->writeFieldBegin("anInteger", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.anInteger);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::aString: {
      xfer += oprot->writeFieldBegin("aString", apache::thrift::protocol::T_STRING, 2);
      xfer += oprot->writeString(this->value_.aString);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t MyField::_reflection_id;
void MyField::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_16778989117799402412(schema);
}

bool MyField::operator == (const MyField & rhs) const {
  if (__isset.opt_value != rhs.__isset.opt_value)
    return false;
  else if (__isset.opt_value && !(opt_value == rhs.opt_value))
    return false;
  if (!(this->value == rhs.value))
    return false;
  if (!(this->req_value == rhs.req_value))
    return false;
  return true;
}

uint32_t MyField::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_16778989117799402412(*schema);
    iprot->setNextStructType(MyField::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->opt_value);
          this->__isset.opt_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->req_value);
          isset_req_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_value)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_value' was not found in serialized data! Struct: MyField");
  return xfer;
}

void MyField::__clear() {
  opt_value = 0;
  value = 0;
  req_value = 0;
  __isset.__clear();
}
uint32_t MyField::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyField");
  if (this->__isset.opt_value) {
    xfer += oprot->writeFieldBegin("opt_value", apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->opt_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("req_value", apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->req_value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyField &a, MyField &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_value, b.opt_value);
  swap(a.value, b.value);
  swap(a.req_value, b.req_value);
  swap(a.__isset, b.__isset);
}

void merge(const MyField& from, MyField& to) {
  using apache::thrift::merge;
  if (from.__isset.opt_value) {
    merge(from.opt_value, to.opt_value);
    to.__isset.opt_value = true;
  }
  if (from.__isset.value) {
    merge(from.value, to.value);
    to.__isset.value = true;
  }
  merge(from.req_value, to.req_value);
}

void merge(MyField&& from, MyField& to) {
  using apache::thrift::merge;
  if (from.__isset.opt_value) {
    merge(std::move(from.opt_value), to.opt_value);
    to.__isset.opt_value = true;
  }
  if (from.__isset.value) {
    merge(std::move(from.value), to.value);
    to.__isset.value = true;
  }
  merge(std::move(from.req_value), to.req_value);
}

const uint64_t MyStruct::_reflection_id;
void MyStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_7958971832214294220(schema);
}

MyStruct::MyStruct(const MyStruct& src1) {
  if (src1.opt_ref)
    opt_ref.reset(new MyField(*src1.opt_ref));
  if (src1.ref)
    ref.reset(new MyField(*src1.ref));
  if (src1.req_ref)
    req_ref.reset(new MyField(*src1.req_ref));
}
bool MyStruct::operator == (const MyStruct & rhs) const {
  if (bool(opt_ref) != bool(rhs.opt_ref))
    return false;
  else if (bool(opt_ref) && !(*opt_ref == *rhs.opt_ref))
    return false;
  if (bool(ref) != bool(rhs.ref))
    return false;
  else if (bool(ref) && !(*ref == *rhs.ref))
    return false;
  if (bool(req_ref) != bool(rhs.req_ref))
    return false;
  else if (bool(req_ref) && !(*req_ref == *rhs.req_ref))
    return false;
  return true;
}

uint32_t MyStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_7958971832214294220(*schema);
    iprot->setNextStructType(MyStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;

  bool isset_req_ref = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            this->opt_ref = std::unique_ptr< MyField>(new MyField);
            xfer += this->opt_ref->read(iprot);
            if (false) {
            } else if (this->opt_ref->__isset.opt_value) {
            } else if (this->opt_ref->__isset.value) {
            } else { this->opt_ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            this->ref = std::unique_ptr< MyField>(new MyField);
            xfer += this->ref->read(iprot);
            if (false) {
            } else if (this->ref->__isset.opt_value) {
            } else if (this->ref->__isset.value) {
            } else { this->ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            this->req_ref = std::unique_ptr< MyField>(new MyField);
            xfer += this->req_ref->read(iprot);
            if (false) {
            } else if (this->req_ref->__isset.opt_value) {
            } else if (this->req_ref->__isset.value) {
            } else { this->req_ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          isset_req_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  if (!isset_req_ref)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_ref' was not found in serialized data! Struct: MyStruct");
  return xfer;
}

void MyStruct::__clear() {
  if (opt_ref) opt_ref->__clear();
  if (ref) ref->__clear();
  if (req_ref) req_ref->__clear();
  __isset.__clear();
}
uint32_t MyStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyStruct");
  xfer += oprot->writeFieldBegin("opt_ref", apache::thrift::protocol::T_STRUCT, 1);
  if (this->opt_ref) {xfer += this->opt_ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ref", apache::thrift::protocol::T_STRUCT, 2);
  if (this->ref) {xfer += this->ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("req_ref", apache::thrift::protocol::T_STRUCT, 3);
  if (this->req_ref) {xfer += this->req_ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyStruct &a, MyStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_ref, b.opt_ref);
  swap(a.ref, b.ref);
  swap(a.req_ref, b.req_ref);
  swap(a.__isset, b.__isset);
}

void merge(const MyStruct& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(from.opt_ref, to.opt_ref);
  merge(from.ref, to.ref);
  merge(from.req_ref, to.req_ref);
}

void merge(MyStruct&& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(std::move(from.opt_ref), to.opt_ref);
  merge(std::move(from.ref), to.ref);
  merge(std::move(from.req_ref), to.req_ref);
}

const uint64_t StructWithUnion::_reflection_id;
void StructWithUnion::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_11295191354176986988(schema);
}

StructWithUnion::StructWithUnion(const StructWithUnion& src3) {
  if (src3.u)
    u.reset(new MyUnion(*src3.u));
  aDouble = src3.aDouble;
  __isset.aDouble = src3.__isset.aDouble;
  f = src3.f;
  __isset.f = src3.__isset.f;
}
bool StructWithUnion::operator == (const StructWithUnion & rhs) const {
  if (bool(u) != bool(rhs.u))
    return false;
  else if (bool(u) && !(*u == *rhs.u))
    return false;
  if (!(this->aDouble == rhs.aDouble))
    return false;
  if (!(this->f == rhs.f))
    return false;
  return true;
}

uint32_t StructWithUnion::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_11295191354176986988(*schema);
    iprot->setNextStructType(StructWithUnion::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          this->u = std::unique_ptr< MyUnion>(new MyUnion);
          xfer += this->u->read(iprot);
          if (this->u->getType() == MyUnion::Type::__EMPTY__) {
            this->u = nullptr; 
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->aDouble);
          this->__isset.aDouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->f.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void StructWithUnion::__clear() {
  if (u) u->__clear();
  aDouble = 0;
  f.__clear();
  __isset.__clear();
}
uint32_t StructWithUnion::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithUnion");
  xfer += oprot->writeFieldBegin("u", apache::thrift::protocol::T_STRUCT, 1);
  if (this->u) {xfer += this->u->write(oprot); 
} else {oprot->writeStructBegin("MyUnion"); oprot->writeStructEnd(); oprot->writeFieldStop();}
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("aDouble", apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->aDouble);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->f.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithUnion &a, StructWithUnion &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.u, b.u);
  swap(a.aDouble, b.aDouble);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithUnion& from, StructWithUnion& to) {
  using apache::thrift::merge;
  merge(from.u, to.u);
  if (from.__isset.aDouble) {
    merge(from.aDouble, to.aDouble);
    to.__isset.aDouble = true;
  }
  if (from.__isset.f) {
    merge(from.f, to.f);
    to.__isset.f = true;
  }
}

void merge(StructWithUnion&& from, StructWithUnion& to) {
  using apache::thrift::merge;
  merge(std::move(from.u), to.u);
  if (from.__isset.aDouble) {
    merge(std::move(from.aDouble), to.aDouble);
    to.__isset.aDouble = true;
  }
  if (from.__isset.f) {
    merge(std::move(from.f), to.f);
    to.__isset.f = true;
  }
}

const uint64_t RecursiveStruct::_reflection_id;
void RecursiveStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_2826922994162023308(schema);
}

bool RecursiveStruct::operator == (const RecursiveStruct & rhs) const {
  if (__isset.mes != rhs.__isset.mes)
    return false;
  else if (__isset.mes && !(mes == rhs.mes))
    return false;
  return true;
}

uint32_t RecursiveStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_2826922994162023308(*schema);
    iprot->setNextStructType(RecursiveStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->mes.clear();
            uint32_t _size6;
            bool _sizeUnknown7;
            apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size6, _sizeUnknown7);
            if (!_sizeUnknown7) {
              this->mes.resize(_size6);
              uint32_t _i11;
              for (_i11 = 0; _i11 < _size6; ++_i11)
              {
                xfer += this->mes[_i11].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                RecursiveStruct _elem12;
                xfer += _elem12.read(iprot);
                this->mes.push_back(_elem12);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void RecursiveStruct::__clear() {
  mes.clear();
  __isset.__clear();
}
uint32_t RecursiveStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RecursiveStruct");
  if (this->__isset.mes) {
    xfer += oprot->writeFieldBegin("mes", apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->mes.size());
      std::vector<RecursiveStruct> ::const_iterator _iter13;
      for (_iter13 = this->mes.begin(); _iter13 != this->mes.end(); ++_iter13)
      {
        xfer += (*_iter13).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecursiveStruct &a, RecursiveStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.mes, b.mes);
  swap(a.__isset, b.__isset);
}

void merge(const RecursiveStruct& from, RecursiveStruct& to) {
  using apache::thrift::merge;
  if (from.__isset.mes) {
    merge(from.mes, to.mes);
    to.__isset.mes = true;
  }
}

void merge(RecursiveStruct&& from, RecursiveStruct& to) {
  using apache::thrift::merge;
  if (from.__isset.mes) {
    merge(std::move(from.mes), to.mes);
    to.__isset.mes = true;
  }
}


